---
title: "R Notebook"
output: html_notebook
---

```{r}
require('MM4LMM')
require('tictoc')
require("sommer")
require("nnet")
require("parallel")
require("Rfast")
require("dplyr")
```

```{r}

# data(DT_technow)
# DT <- DT_technow
# 
# Mf <- Mf_technow
# Md <- Md_technow
# 
# Zf <- class.ind(DT$flint)
# Zf <- Zf[,rownames(Mf)]
# 
# Zd <- class.ind(DT$dent)
# Zd <- Zd[,rownames(Md)]
# 
# Pheno  <- read.csv("/work_home/jwang/stage_partie2/Test_Result09/trait_[nqtl.d=10][nqtl.f=10][ad_=20][af_=20][gamma=0.00][h=0.90][Poly.size.d=0][Poly.size.f=0][Poly.effet.d=0.000][Poly.effet.f=0.000][tn=1][b=1.00].dat", sep = " ", header = TRUE)[,1]
# 
# Geno1 <- Mf_technow*2
# Geno2 <- Md_technow*2
# 
# Z1 <- Zf
# Z2 <- Zd
# 
# genome_names = c("G1", "G2")
# max_itr_num = 30 
# gamma = 0.1
# Method = "ML"
# 
# Geno1 <- Geno1[,1:2000]
# Geno2 <- Geno2[,1:2000]
```

```{r}
# AMTOMM
PWD <- getwd()

Pheno <- read.csv(paste0(PWD, "/AMTOMM_DS/phenotype.txt"), header = FALSE, sep = " ")
names(Pheno) <- c("hostID", "pathogenID", "intercept", "X1", "X2")

Hosts <- t(read.csv(paste0(PWD, "/AMTOMM_DS/sequence_host.txt"), header = FALSE, sep = " "))
rownames(Hosts) <- c("chrID", "snpID", paste0(rep("H", 50), 1:50))
colnames(Hosts) <- paste0(Hosts[1,], rep("-", ncol(Hosts)), Hosts[2,])

Pathogens <- t(read.csv(paste0(PWD, "/AMTOMM_DS/sequence_pathogen.txt"), header = FALSE, sep = " "))
rownames(Pathogens) <- c("chrID", "snpID", paste0(rep("P", 40), 1:40))
colnames(Pathogens) <- paste0(Pathogens[1,], rep("-", ncol(Pathogens)), Pathogens[2,])

H <- Hosts[3:52,] * 2 - 1
P <- Pathogens[3:42,] * 2 - 1
HP<- .tensor.product(H,P)

while (TRUE) {
  Hs <- lapply(1:20, function(x) sort(sample(1:50, 20)))
  Ps <- lapply(1:20, function(x) sort(sample(1:40, 20)))  
  if (length(unique(unlist(Hs))) >= 50 && length(unique(unlist(Ps))) >= 40) break 
}

Zh <- matrix(0, ncol = 50,   nrow = 400)
Zp <- matrix(0, ncol = 40,   nrow = 400)
Zi <- matrix(0, ncol = 2000, nrow = 400)

for (i in 1:400) {
  Zh[i,  unlist(Hs)[i]] <- 1
  Zp[i,  unlist(Ps)[i]] <- 1
  Zi[i, (unlist(Hs)[i] - 1) * 40 + unlist(Ps)[i]] <- 1
}

# verifiy Zi
Z <- .row.tensor.product(Zh, Zp)
unique(as.numeric(Z - Zi))

```

#### Simulation

```{r}
gamma <- 0

ah_ <- 10 # fixed
ap_ <- 10 # fixed 
ai_ <- 10 # fixed 

nqtl.h = 10 # fixed
nqtl.p = 10 # fixed
nqtl.i = 10 # fixed

Freq.h <- colMeans(H)
Freq.p <- colMeans(P)
Freq.i <- colMeans(HP)
    
Poly.size.h <- 0 # fixed
Poly.size.p <- 0 # fixed
Poly.size.i <- 0 # fixed

Poly.effet.h <- 0
Poly.effet.p <- 0
Poly.effet.i <- 0

PWD <- paste0(getwd(),"/Test_Result01/")
label <- "[nqtl.h=%d][nqtl.p=%d][nqtl.i=%d][ah_=%d][ap_=%d][ai_=%d][Poly.size.h=%d][Poly.size.p=%d][Poly.size.i=%d][Poly.effet.h=%.3f][Poly.effet.p=%.3f][Poly.effet.i=%.3f][gamma=%.2f][h=%.2f][b=%.2f][tn=%d]"

save_model <- function(nqtl.h, nqtl.p, nqtl.i, Sh, Sp, Si, ahS, apS, aiS, ah_s, ap_s, ai_s, E, fname) {
  saveRDS(object = list("nqtl.h" = nqtl.h, "nqtl.p" = nqtl.p, "nqtl.i" = nqtl.i, "Sh" = Sh, "Sp" = Sp, "Si" = Si, 
                        "ahS" = ahS, "apS" = apS, "aiS" = aiS, "ah_s" = ah_s, "ap_s" = ap_s, "ai_s" = ai_s, "E" = E), 
                        file = fname)
}

save_trait <- function(Y, fname) {
  write.table(list("Trait" = Y), file = fname, 
              row.names =  FALSE, sep = " ", quote = FALSE)
}

sl_label <- function(h, b, tn) {
  return(sprintf(label, nqtl.h, nqtl.p, nqtl.i, ah_, ap_, ai_, Poly.size.h, Poly.size.p, Poly.size.i, Poly.effet.h, Poly.effet.p, Poly.effet.i, gamma, h, b, tn))
}

model_fname <- function(h, b, tn) {
  return(paste0(PWD, "model_", sl_label(h,b,tn), ".rds"))
}

trait_fname <- function(h, b, tn) {
  return(paste0(PWD, "trait_", sl_label(h,b,tn), ".dat"))
}

sl <- function (h, b, tn) {
  
  if (file.exists(model_fname(h,b,tn))) {
    return(NULL)
  }
  
  while(TRUE) {
    
    Informative.h <- which(Freq.h > 10/nrow(H) & Freq.h < 1-10/nrow(H))
    Informative.p <- which(Freq.p > 10/nrow(P) & Freq.p < 1-10/nrow(P))
    Informative.i <- which(Freq.i > 10/nrow(HP) & Freq.p < 1-10/nrow(HP))
    
    Sh <- sample(Informative.h, nqtl.h)
    Sp <- sample(Informative.p, nqtl.p)
    Si <- sample(Informative.i, nqtl.i)
    
    Hs <- H[, Sh]
    Ps <- P[, Sp]
    Is <- HP[,Si]
    
    H_s <- H[, -Sh]
    P_s <- P[, -Sp]
    I_s <- HP[,-Si]
    
    ah_s <- rep(0,ncol(H_s))
    ap_s <- rep(0,ncol(P_s))
    ai_s <- rep(0,ncol(I_s))

    ah_s[sample(1:length(ah_s), Poly.size.h)] <- runif(min = -Poly.effet.h, max = Poly.effet.h, n = Poly.size.h)
    ap_s[sample(1:length(ap_s), Poly.size.p)] <- runif(min = -Poly.effet.p, max = Poly.effet.p, n = Poly.size.p)
    ai_s[sample(1:length(ai_s), Poly.size.i)] <- runif(min = -Poly.effet.i, max = Poly.effet.i, n = Poly.size.i)
    
    ahS <- seq(ah_,ah_+nqtl.h,l=nqtl.h)
    apS <- seq(ap_,ap_+nqtl.p,l=nqtl.p)
    aiS <- seq(ai_,ai_+nqtl.i,l=nqtl.i)
    
    Uh <- Hs %*% ahS + H_s %*% ah_s
    Up <- Ps %*% apS + P_s %*% ap_s
    Ui <- Is %*% aiS + I_s %*% ai_s
    
    Uh <- Zh %*% Uh + Zp %*% Up + Zi %*% Ui
    Ua <- Zh %*% Hs %*% ahS + Zp %*% Ps %*% apS + Zi %*% Is %*% aiS
    
    vg <- var(Uh)
    va <- var(Ua)
    
    a_ratio <- va/vg
    
    # if (a_ratio < (b+0.02) && a_ratio > (b-0.02) && !file.exists(model_fname(h,b,tn))) {
    if (a_ratio < (b+0.02) && a_ratio > (b-0.02)) {
      sigma_E <- as.numeric(sqrt(vg*(1-h)/h))
      E <- sigma_E * rnorm(length(Uh))
      Y <- Uh + E
      save_model(nqtl.h = nqtl.h, nqtl.p = nqtl.p, nqtl.i = nqtl.i, 
                 Sh = Sh, Sp = Sp, Si = Si, ahS = ahS, apS = apS, aiS = aiS, 
                 ah_s = ah_s, ap_s = ap_s, ai_s = ai_s, E = E, fname = model_fname(h,b,tn))
      
      save_trait(Y, fname = trait_fname(h,b,tn))
      
      return(a_ratio)
    }
  }
}
```

```{r}
sl(h = 0.9, b = 1, tn = 1)
```

```{r}
Pheno <- read.csv(trait_fname(h = 0.9, b = 1, tn = 1))[, 1]

Geno1 <- H
Geno2 <- P

Z1 <- Zh
Z2 <- Zp
Zi <- Zi

max_itr_num <- 50
genome_names <- c("Host", "Pathogen")
Method <- "ML"
```


```{r}

.col.tensor.product<- function(A,B) {
  # rule: nrow(A) == row(B)
  return(matrix(mapply(function(x, i) x * B[,i], A, col(A)), ncol = ncol(A)))
}

.row.tensor.product<- function(A,B) {
  return(t(.col.tensor.product(t(A), t(B))))
}

.tensor.product <- function(A,B) {
  # https://en.wikipedia.org/wiki/Tensor_product
  AoB <- A%o%B
  return(do.call(rbind, mclapply(1:nrow(A), function(i) do.call(cbind,  lapply(1:ncol(A), function(j) (AoB)[i,j,,])), 
                                 mc.cores = getOption("mc.cores", 48L))))
}

G1 <- list("G" = NULL, "Z" = NULL, "K" = NULL, "K_" = NULL, "MMt" = NULL, "ZMMtZt" = NULL,
          "ZM" = NULL, "selected_locus" = NULL, "selected_locus_names" = NULL, "name" = "G1", "SNPs_names" = NULL)

G2 <- list("G" = NULL, "Z" = NULL, "K" = NULL, "K_" = NULL, "MMt" = NULL, "ZMMtZt" = NULL,
          "ZM" = NULL, "selected_locus" = NULL, "selected_locus_names" = NULL, "name" = "G2", "SNPs_names" = NULL)

IA <- list("Z" = NULL, "K" = NULL, "selected_locus1" = c(), "selected_locus2" = c(), "name" = "Interaction")

Y <- as.numeric(Pheno)

G1$G <- as.matrix(Geno1) - 1
G2$G <- as.matrix(Geno2) - 1

G1$Z <- Z1
G2$Z <- Z2
IA$Z <- Zi

G1$SNPs_names <- colnames(Geno1)
G2$SNPs_names <- colnames(Geno2)

G1$ncol <- ncol(G1$G)
G2$ncol <- ncol(G2$G)

if (is.null(G1$Z)) G1$Z <- diag(nrow(G1$G))
if (is.null(G1$Z)) G1$Z <- diag(nrow(G1$G))
if (is.null(IA$Z)) {
  IA$Z <- .row.tensor.product(G1$Z, G2$Z)
}

X <- matrix(data = 1, nrow = length(Pheno), ncol = 1)
colnames(X) <- c("intercept")

Init  <- NULL
total_SNPs_num <- ncol(G1$G) + ncol(G2$G)

selected_locus <- list("G1" = c(), "G2" = c(), "IA" = list(), "order" = c(), 
                       "names1" = c(), "names2" = c(), "names_ia" = list())

bic_history <- c()
extBIC_history <- c() 
loglik <- 0
loglik_history <- c()
vg_history <- list("G1"=c(), "G2"=c(), "IA" = c(), "Error"=c())

loci_name <- NULL
loci_genome <- NULL # equal to 1 or 2

.build.GO <- function(Geno) {
  Geno$MMt <- Tcrossprod(Geno$G, Geno$G)
  Geno$ZM  <- mat.mult(Geno$Z, Geno$G)
  Geno$ZMMtZt <- mat.mult(Geno$Z, Tcrossprod(Geno$MMt,Geno$Z))
  # VERSION Eagle
  # K <- MMt/max(MMt) + diag(0.95, nrow(MMt))
  Geno$K  <- Geno$MMt/mean(diag(Geno$MMt))
  Geno$K_ <- Geno$ZMMtZt/mean(diag(Geno$ZMMtZt))
  return(Geno)
}

.build.IA <- function(IA, G1, G2) {
  # 10.1 sec elapsed
  if(is.null(IA$Z)) IA$Z <- .row.tensor.product(G1$Z, G2$Z)
  IA$K <- .tensor.product(G1$K, G2$K)
  IA$K_<-  mat.mult(IA$Z, Tcrossprod(IA$K,IA$Z))
  return(IA)
}

.update.IA <- function(IA, G1, G2, loci_ia = NULL) {
  IA$K <- .tensor.product(G1$K, G2$K)
  IA$K_<-  mat.mult(IA$Z, Tcrossprod(IA$K,IA$Z))

  if(!is.null(loci_ia)) {
    IA$G1_selected_locus <- c(IA$G1_selected_locus, loci_ia[1])
    IA$G2_selected_locus <- c(IA$G2_selected_locus, loci_ia[2])
    IA$G1_selected_locus_names <- c(IA$G1_selected_locus_names, G1$SNPs_names[loci_ia[1]])
    IA$G2_selected_locus_names <- c(IA$G2_selected_locus_names, G2$SNPs_names[loci_ia[2]])
  }
  
  return(IA)
}

.update.GO <- function(Geno, loci) {
  # loci <- Geno$G[which(!selected_locus %in% Geno$selected_locus)]
  MMt_ <- tcrossprod(Geno$G[, loci])
  Geno$MMt <- Geno$MMt - MMt_
  Geno$ZMMtZt  <- Geno$ZMMtZt - mat.mult(Geno$Z, Tcrossprod(MMt_,Geno$Z))
  Geno$K   <- Geno$MMt/mean(diag(Geno$MMt))
  # ZMMtZt = Z %*% K %*% t(Z)
  Geno$K_  <- Geno$ZMMtZt/mean(diag(Geno$MMt))
  Geno$selected_locus <- c(Geno$selected_locus, loci)
  return(Geno)
}

.build.X <- function(G1, G2) {
  
}

.calc.snps.scores <- function(a_hat, diag_var_a_hat, L, snps_names, selected_locus, genome_name) {
  # calculate snps scores
  indx <- which(diag_var_a_hat != 0)
  tsq <- a_hat[indx]^2/diag_var_a_hat[indx]
  names(tsq) <- seq(1, length(a_hat))[indx]
  best_score <- max(tsq, na.rm = TRUE)
  indx <- which(tsq == best_score)

  # deal with the case of more than one snps reach the best score
  midpoint <- 1
  if (length(indx) > 2) midpoint <- trunc(length(indx)/2) + 1
  indx <- indx[midpoint]
  orig_indx <- seq(1, L)
  loci_idx <- orig_indx[as.numeric(names(tsq))[indx]]

  # snps name and global index
  if (!is.null(selected_locus)) {
    score_names <- snps_names[-selected_locus]
  } else {
    score_names <- snps_names
  }

  loci_name <- score_names[loci_idx]
  loci_idx <- which(snps_names==loci_name)

  return(list("loci_name" = loci_name, "loci_idx" = loci_idx, "score" = best_score))
}


.find.putative.qtl <- function(G1, G2, IA, Y, P_gamma, Sigma_gamma) {
  
  PgY <- crossprod(P_gamma, Y)
  PSP <- Tcrossprod(P_gamma, Sigma_gamma) %>% Tcrossprod(., P_gamma)
  
  #### G1
  if(is.null(G1$selected_locus)) {
    M1_s <- G1$G
  } else {
    M1_s <- G1$G[, -G1$selected_locus]
  }
  
  a1 <- Crossprod(G1$Z,PgY) %>% Crossprod(M1_s, .)
  P1 <- Crossprod(G1$Z, PSP) %>%  mat.mult(.,G1$Z)
  diag_var_a1 <- rowSums(Crossprod(M1_s, P1) * t(M1_s))
  score1 <- .calc.snps.scores(a1, diag_var_a1, ncol(G1$G), G1$SNPs_names, G1$selected_locus, G1$name)
  
  #### G2 
  if(is.null(G2$selected_locus)) {
    M2_s <- G2$G
  } else {
    M2_s <- G2$G[, -G2$selected_locus]
  }
  
  a2 <- Crossprod(G2$Z,PgY) %>% Crossprod(M2_s, .)
  P2 <- Crossprod(G2$Z, PSP) %>% mat.mult(.,G2$Z)  
  diag_var_a2 <- rowSums(Crossprod(M2_s, P2) * t(M2_s))
  score2 <- .calc.snps.scores(a2, diag_var_a2, ncol(G2$G), G2$SNPs_names, G2$selected_locus, G2$name)
  
  if (is.null(G1$selected_locus)) {
    ZM1 <- G1$ZM
  } else {
    ZM1 <- G1$ZM[, - G1$selected_locus]
  }
  
  if (is.null(G2$selected_locus)) {
    ZM2 <- G2$ZM
  } else {
    ZM2 <- G2$ZM[, - G2$selected_locus]
  }
  
  #### Gi
  # mclapply super slow 
  # 2000 snps by lapply: 365.56 sec elapsed
  
  scores_ia <- lapply(c(1:ncol(ZM1)), function(i) {
    ZM1ixZM2 <- ZM1[,i]*ZM2
    ai <- Crossprod(ZM1ixZM2, PgY)
    diag_var_ai <- colSums(t(Crossprod(ZM1ixZM2,PSP))*ZM1ixZM2)
    scorei <- .calc.snps.scores(ai, diag_var_ai, G2$ncol, G2$SNPs_names, G2$selected_locus, IA$name)
    return(scorei)
  }) 
  
  return(list("G1" = score1, "G2" = score2, "IA" = scores_ia))
}

```


```{r}

# tryCatch({

  for (itr_num in 3:max_itr_num) {
    
    message(sprintf("\nIteration: %d", itr_num))
    
    #### #### #### ####    STEP 1 model building    #### #### #### ####
    if (is.null(loci_genome)) {
      G1 <- .build.GO(G1)
      G2 <- .build.GO(G2)
      IA <- .build.IA(IA, G1, G2)
    } else if (loci_genome == 1) {
      G1 <- .update.GO(G1,  selected_locus$G1[length(selected_locus$G1)])
      IA <- .update.IA(IA, G1, G2)
      X  <- cbind(X, G1$ZM[,selected_locus$G1[length(selected_locus$G1)]])
    } else if (loci_genome == 2) {
      G2 <- .update.GO(G2,  selected_locus$G2[length(selected_locus$G2)])
      IA <- .update.IA(IA, G1, G2)
      X  <- cbind(X, G2$ZM[,selected_locus$G2[length(selected_locus$G2)]])
    } else {
      locus_ia <- selected_locus$IA[[length(selected_locus$IA)]]
      G1 <- .update.GO(G1, locus_ia[1])
      G2 <- .update.GO(G2, locus_ia[2])
      IA <- .update.IA(IA, G1, G2, locus_ia)
      X  <- cbind(X, G1$ZM[, locus_ia[1]])
      X  <- cbind(X, G2$ZM[, locus_ia[2]])
    }
    
    tic()
    VL <- list(G1 = G1$K, G2 = G2$K, IA = IA$K, Error = diag(1,length(Y)))
    ZL <- list(G1 = G1$Z, G2 = G2$Z, IA = IA$Z, Error = diag(1,length(Y)))
    
    if (!is.null(genome_names)) {
      names(VL) <- c(genome_names, "Interaction", "Error")
      names(ZL) <- c(genome_names, "Interaction", "Error")
    }
    
    if (is.null(Init)) {
      Init <- rep(var(Pheno)/4,4)
    }

    res <- MMEst(Y = Pheno, Cofactor = X, Method = Method,
                 VarList = VL, ZList = ZL, Init = Init,
                 MaxIter = 400, CritLogLik = 0.0001)

    # Note: vg, ve, loglik are very slightly different from Eagle's
    vg1 <- res$NullModel$Sigma2[genome_names[1]]
    vg2 <- res$NullModel$Sigma2[genome_names[2]]
    vgi <- res$NullModel$Sigma2["Interaction"]
    ve <- res$NullModel$Sigma2["Error"]
    
    Init <- c(vg1, vg2, vgi, ve)
    
    toc()
    # To calculate log likelihood, MM4LMM use gradient descent, meanwhile Eagle use grid.   
    if (!is.null(res$NullModel$`LogLik (ML)`)) {
      loglik <- res$NullModel$`LogLik (ML)`   
    } else {
      loglik <- res$NullModel$`LogLik (Reml)`
    }
    
    message(sprintf("log likelihood: %f, var G1: %f, var G2: %f, var vgi: %f, var E: %f", loglik, vg1, vg2, vgi, ve))
    
    #### #### #### ####    STEP 2 model evaluation   #### #### #### #### 
    # Degree of freedom of Eagle's extend BIC equals to 1
    bic <- -2 * loglik + (ncol(X)+1) * log(length(Pheno))
    ext_bic <- bic + 2 * gamma * lchoose(total_SNPs_num, length(selected_locus$order))
    
    message(sprintf("BIC: %f, extend BIC: %f", bic, ext_bic))
    
    bic_history <- c(bic_history, bic)
    extBIC_history <- c(extBIC_history, ext_bic)
    vg_history$G1 <- c(vg_history$G1, vg1)
    vg_history$G2 <- c(vg_history$G1, vg2)
    vg_history$IA <- c(vg_history$IA, vgi)
    vg_history$Error <- c(vg_history$Error, ve)
    loglik_history <- c(loglik_history, loglik)

    #### #### #### ####    STEP 3 model selection   #### #### #### ####  
    tic()
    Sigma_gamma <- diag(ve, nrow = nrow(G1$K_)) + vg1 * G1$K_ + vg2 * G2$K_ + vgi * IA$K_
    Sigma_gamma_1 <- chol2inv(cholesky(Sigma_gamma, parallel = TRUE))
    XtS_1 <- Crossprod(X, Sigma_gamma_1)
    P_gamma <-  Sigma_gamma_1 - chol2inv(cholesky(Crossprod(X, t(XtS_1)), parallel = TRUE)) %>% Crossprod(., XtS_1) %>% Crossprod(XtS_1, .)
    toc()
    
    tic()    
    scores <- .find.putative.qtl(G1, G2, IA, Y, P_gamma, Sigma_gamma)
    toc()
    
    ia_scores_df <- as.data.frame(do.call(rbind, scores$IA))
    ia_best_score <- as.numeric(ia_scores_df$score[which.max(ia_scores_df$score)])
    
    if ( scores$G1$score > scores$G2$score && scores$G1$score > ia_best_score) {
      loci_genome <- 1
      selected_locus$order <- c(selected_locus$order, loci_genome)
      selected_locus$G1 <- c(selected_locus$G1, scores$G1$loci_idx)
      selected_locus$names1 <- c(selected_locus$names1, scores$G1$loci_name)
      message(sprintf("[%s] new selected loci: %s, index: %d", genome_names[1], scores$G1$loci_name, scores$G1$loci_idx))
    } else if ( scores$G2$score > scores$G1$score && scores$G2$score > ia_best_score ) {
      loci_genome <- 2
      selected_locus$order <- c(selected_locus$order, loci_genome)
      selected_locus$G2 <- c(selected_locus$G2, scores$G2$loci_idx)
      selected_locus$names2 <- c(selected_locus$names2, scores$G2$loci_name)
      message(sprintf("[%s] new selected loci: %s, index: %d", genome_names[2], scores$G2$loci_name, scores$G2$loci_idx))
    } else {
      loci_genome <- 3
      selected_locus$order <- c(selected_locus$order, loci_genome)
      G1_best_idx <- which.max(ia_scores_df$score)
      G2_best_idx <- as.numeric(ia_scores_df$loci_idx[G1_best_idx])
      selected_locus$IA[[length(selected_locus$IA)+1]] <- c(G1_best_idx, G2_best_idx)
      selected_locus$names_ia[[length(selected_locus$names_ia)+1]] <- c(G1$SNPs_names[G1_best_idx], G2$SNPs_names[G2_best_idx])
      message(sprintf("new interaction locus: %s and %s, index: %d and %d", 
                      G1$SNPs_names[G1_best_idx], G2$SNPs_names[G2_best_idx], G1_best_idx, G2_best_idx))
    }
    
    
  }
# }, warning = function(warn) {
#   print(paste("EMG WARNING MESSAGE: ", warn))
# }, error = function(err) {
#   print(paste("EMG ERROR MESSAGE: ", err))
# }, finally = function(f) {
#   selected_locus$extBIC <- extBIC_history
#   selected_locus$loglik <- loglik_history
# })

selected_locus$extBIC <- extBIC_history
selected_locus$loglik <- loglik_history

```

