---
title: "R Notebook"
output: html_notebook
---

```{r}
require('MM4LMM')
require('tictoc')
require("sommer")
require("nnet")
require("parallel")
require("Rfast")
require("dplyr")
```

```{r}

data(DT_technow)
DT <- DT_technow

Mf <- Mf_technow
Md <- Md_technow

Zf <- class.ind(DT$flint)
Zf <- Zf[,rownames(Mf)]

Zd <- class.ind(DT$dent)
Zd <- Zd[,rownames(Md)]

```



```{r}

Pheno  <- read.csv("/work_home/jwang/stage_partie2/Test_Result09/trait_[nqtl.d=10][nqtl.f=10][ad_=20][af_=20][gamma=0.00][h=0.90][Poly.size.d=0][Poly.size.f=0][Poly.effet.d=0.000][Poly.effet.f=0.000][tn=1][b=1.00].dat", sep = " ", header = TRUE)[,1]

Geno1 <- Mf_technow*2
Geno2 <- Md_technow*2

Z1 <- Zf
Z2 <- Zd

genome_names = c("G1", "G2")
max_itr_num = 30 
gamma = 0.1
Method = "ML"

Geno1 <- Geno1[,1:2000]
Geno2 <- Geno2[,1:2000]
```


```{r}

.col.tensor.product<- function(A,B) {
  # rule: nrow(A) == row(B)
  return(matrix(mapply(function(x, i) x * B[,i], A, col(A)), ncol = ncol(A)))
}

.row.tensor.product<- function(A,B) {
  return(t(.col.tensor.product(t(A), t(B))))
}

.tensor.product <- function(A,B) {
  # https://en.wikipedia.org/wiki/Tensor_product
  AoB <- A%o%B
  return(do.call(rbind, mclapply(1:nrow(A), function(i) do.call(cbind,  lapply(1:ncol(A), function(j) (AoB)[i,j,,])), 
                                 mc.cores = getOption("mc.cores", 48L))))
}

G1 <- list("G" = NULL, "Z" = NULL, "K" = NULL, "K_" = NULL, "MMt" = NULL, "ZMMtZt" = NULL,
          "ZM" = NULL, "selected_locus" = NULL, "selected_locus_names" = NULL, "name" = "G1", "SNPs_names" = NULL)
G2 <- list("G" = NULL, "Z" = NULL, "K" = NULL, "K_" = NULL, "MMt" = NULL, "ZMMtZt" = NULL,
          "ZM" = NULL, "selected_locus" = NULL, "selected_locus_names" = NULL, "name" = "G2", "SNPs_names" = NULL)
IA <- list("Z" = NULL, "K" = NULL, "G1_selected_locus" = NULL, "G2_selected_locus" = NULL,
          "G1_selected_locus_names" = NULL, "G2_selected_locus_names" = NULL,  "name" = "Interaction")

Y <- as.numeric(Pheno)

G1$G <- as.matrix(Geno1) - 1
G2$G <- as.matrix(Geno2) - 1

G1$Z <- Z1
G2$Z <- Z2

G1$SNPs_names <- colnames(Geno1)
G2$SNPs_names <- colnames(Geno2)

if (is.null(G1$Z)) G1$Z <- diag(nrow(G1$G))
if (is.null(G1$Z)) G1$Z <- diag(nrow(G1$G))
if (is.null(IA$Z)) {
  IA$Z <- .row.tensor.product(G1$Z, G2$Z)
}

X <- matrix(data = 1, nrow = length(Pheno), ncol = 1)
colnames(X) <- c("intercept")

Init  <- NULL
total_SNPs_num <- ncol(G1$G) + ncol(G2$G)

selected_locus <- list("G1" = c(), "G2" = c(), "IA" = c(), "order" = c())
selected_locus_names <- list("G1" = c(), "G2" = c(), "IA" = c())
bic_history <- c()
extBIC_history <- c() 
loglik <- 0
loglik_history <- c()
vg_history <- list("G1"=c(), "G2"=c(), "IA" = c(), "Error"=c())

loci_name <- NULL
loci_genome <- NULL # equal to 1 or 2

.build.GO <- function(Geno) {
  Geno$MMt <- Tcrossprod(Geno$G, Geno$G)
  Geno$ZM  <- mat.mult(Geno$Z, Geno$G)
  Geno$ZMMtZt <- mat.mult(Geno$Z, Tcrossprod(Geno$MMt,Geno$Z))
  # VERSION Eagle
  # K <- MMt/max(MMt) + diag(0.95, nrow(MMt))
  Geno$K  <- Geno$MMt/mean(diag(Geno$MMt))
  Geno$K_ <- Geno$ZMMtZt/mean(diag(Geno$ZMMtZt))
  return(Geno)
}

.build.IA <- function(IA, G1, G2) {
  # 10.1 sec elapsed
  IA$Z <- .row.tensor.product(G1$Z, G2$Z)
  IA$K <- .tensor.product(G1$K, G2$K)
  IA$K_<-  mat.mult(IA$Z, Tcrossprod(IA$K,IA$Z))
  return(IA)
}

.update.GO <- function(Geno, loci) {
  # loci <- Geno$G[which(!selected_locus %in% Geno$selected_locus)]
  MMt_ <- Tcrossprod(Geno$G[, loci])
  Geno$MMt <- Geno$MMt - MMt_
  Geno$ZMMtZt  <- Geno$ZMMtZt - mat.mult(Geno$Z, Tcrossprod(MMt_,Geno$Z))
  Geno$K   <- Geno$MMt/mean(diag(Geno$MMt))
  # ZMMtZt = Z %*% K %*% t(Z)
  Geno$K_  <- Geno$ZMMtZt/mean(diag(Geno$MMt))
  Geno$selected_locus <- c(Geno$selected_locus, loci)
  return(Geno)
}

# .calc.a <- function(Z, M_s, Pheno, P_gamma, Sigma_gamma) {
#   a_hat <- crossprod(M_s, crossprod(Z,crossprod(P_gamma, Pheno)))
#   P <- crossprod(Z, P_gamma) %>% tcrossprod(., Sigma_gamma) %>% tcrossprod(., P_gamma) %>% tcrossprod(.,t(Z))
#   diag_var_a_hat <- rowSums(crossprod(M_s, P) * t(M_s))
#   return(list("a_hat" = a_hat, "var_a_hat" = diag_var_a_hat))
# }
# 
.calc.snps.scores <- function(a_hat, diag_var_a_hat, L, snps_names, selected_locus, genome_name) {
  # calculate snps scores
  indx <- which(diag_var_a_hat != 0)
  tsq <- a_hat[indx]^2/diag_var_a_hat[indx]
  names(tsq) <- seq(1, length(a_hat))[indx]
  best_score <- max(tsq, na.rm = TRUE)
  indx <- which(tsq == best_score)

  # deal with the case of more than one snps reach the best score
  midpoint <- 1
  if (length(indx) > 2) midpoint <- trunc(length(indx)/2) + 1
  indx <- indx[midpoint]
  orig_indx <- seq(1, L)
  loci_idx <- orig_indx[as.numeric(names(tsq))[indx]]

  # snps name and global index
  if (!is.null(selected_locus)) {
    score_names <- snps_names[-selected_locus]
  } else {
    score_names <- snps_names
  }

  loci_name <- score_names[loci_idx]
  loci_idx <- which(snps_names==loci_name)

  # message(sprintf("[%s] the highest score snps index : %d, snp name: %s, snp score: %f", genome_name, loci_idx, loci_name, best_score))

  return(list("loci_name" = loci_name, "loci_idx" = loci_idx, "score" = best_score))
}


.find.putative.qtl <- function(G1, G2, IA, Y, P_gamma, Sigma_gamma) {
  
  PgY <- crossprod(P_gamma, Y)
  PSP <- Tcrossprod(P_gamma, Sigma_gamma) %>% Tcrossprod(., P_gamma)
  
  #### G1
  if(is.null(G1$selected_locus)) {
    M1_s <- G1$G
  } else {
    M1_s <- G1$G[, G1$selected_locus]
  }
  
  a1 <- Crossprod(G1$Z,PgY) %>% Crossprod(M1_s, .)
  P1 <- Crossprod(G1$Z, PSP) %>%  mat.mult(.,G1$Z)
  diag_var_a1 <- rowSums(Crossprod(M1_s, P1) * t(M1_s))
  score1 <- .calc.snps.scores(a1, diag_var_a1, ncol(G1$G), G1$SNPs_names, G1$selected_locus, G1$name)
  
  #### G2 
  if(is.null(G2$selected_locus)) {
    M2_s <- G2$G
  } else {
    M2_s <- G2$G[, G2$selected_locus]
  }
  
  a2 <- Crossprod(G2$Z,PgY) %>% Crossprod(M2_s, .)
  P2 <- Crossprod(G2$Z, PSP) %>% mat.mult(.,G2$Z)  
  diag_var_a2 <- rowSums(Crossprod(M2_s, P2) * t(M2_s))
  score2 <- .calc.snps.scores(a2, diag_var_a2, ncol(G2$G), G2$SNPs_names, G2$selected_locus, G2$name)
  
  if (is.null(G1$selected_locus)) {
    ZM1 <- G1$ZM
  } else {
    ZM1 <- G1$ZM[, - G1$selected_locus]
  }
  
  if (is.null(G2$selected_locus)) {
    ZM2 <- G2$ZM
  } else {
    ZM2 <- G2$ZM[, - G2$selected_locus]
  }
  
  #### Gi
  # mclapply super slow 
  # 2000 snps by lapply: 365.56 sec elapsed
  
  scores_ia <- lapply(c(1:ncol(G1$G)), function(i) {
  tic()
    ZM1ixZM2 <- ZM1[,i]*ZM2
    ai <- Crossprod(ZM1ixZM2, PgY)
    diag_var_ai <- colSums(t(Crossprod(ZM1ixZM2,PSP))*ZM1ixZM2)
    scorei <- .calc.snps.scores(ai, diag_var_ai, ncol(G2$G), G2$SNPs_names, G2$selected_locus, IA$name)
  toc()
    return(scorei)
  }) # , mc.cores = getOption("mc.cores", 2L))
  
  # Too slow
  # cl <- makeCluster(getOption("cl.cores", 4))
  # setDefaultCluster(cl)
  # clusterExport(NULL, varlist = c("Crossprod", "colSums", ".calc.snps.scores", "G1", "G2", "IA", "ZM1", "ZM2", "PgY", "PSP"))
  # tic()
  # scores_ia2 <- parLapply(cl, c(1:ncol(G1$G)), function(i) {
  #   ZM1ixZM2 <- ZM1[,i]*ZM2
  #   ai <- Crossprod(ZM1ixZM2, PgY)
  #   diag_var_ai <- colSums(t(Crossprod(ZM1ixZM2,PSP))*ZM1ixZM2)
  #   scorei <- .calc.snps.scores(ai, diag_var_ai, ncol(G2$G), G2$SNPs_names, G2$selected_locus, IA$name)
  #   return(scorei)
  # })
  # toc()
  # stopCluster(cl)
  return(list("G1" = score1, "G2" = score2, "IA" = scores_ia))
}


```


```{r}

tryCatch({
  
  for (itr_num in 1:max_itr_num) {
    
    message(sprintf("\nIteration: %d", itr_num))
    
    #### #### #### ####    STEP 1 model building    #### #### #### ####
    if (is.null(loci_genome)) {
      G1 <- .build.GO(G1)
      G2 <- .build.GO(G2)
      IA <- .build.IA(IA, G1, G2)
    } else if (loci_genome == 1) {
      G1 <- .update.GO(G1,  selected_locus$G1[length(selected_locus$G1)])
      X  <- cbind(X, G1$ZM[,selected_locus$G1[length(selected_locus$G1)]])
    } else if (loci_genome == 2) {
      G2 <- .update.GO(G2,  selected_locus$G2[length(selected_locus$G2)])
      X  <- cbind(X, G2$ZM[,selected_locus$G2[length(selected_locus$G2)]])
    } else {
      G1 <- .update.GO(G1, selected_locus$G1[length(selected_locus$G1)])
      G2 <- .update.GO(G2, selected_locus$G2[length(selected_locus$G2)])
      IA <- .build.IA(IA, G1, G2)
      X  <- cbind(X, G1$ZM[,selected_locus$G1[length(selected_locus$G1)]])
      X  <- cbind(X, G2$ZM[,selected_locus$G2[length(selected_locus$G2)]])
    }
    
    tic()
    VL <- list(G1 = G1$K, G2 = G2$K, IA = IA$K, Error = diag(1,length(Y)))
    ZL <- list(G1 = G1$Z, G2 = G2$Z, IA = IA$Z, Error = diag(1,length(Y)))
    
    if (!is.null(genome_names)) {
      names(VL) <- c(genome_names, "Interaction", "Error")
      names(ZL) <- c(genome_names, "Interaction", "Error")
    }
    
    if (is.null(Init)) {
      Init <- rep(var(Pheno)/4,4)
    }

    res <- MMEst(Y = Pheno, Cofactor = X, Method = Method,
                 VarList = VL, ZList = ZL, Init = Init,
                 MaxIter = 400, CritLogLik = 0.0001)

    # Note: vg, ve, loglik are very slightly different from Eagle's
    vg1 <- res$NullModel$Sigma2[genome_names[1]]
    vg2 <- res$NullModel$Sigma2[genome_names[2]]
    vgi <- res$NullModel$Sigma2["Interaction"]
    ve <- res$NullModel$Sigma2["Error"]
    
    Init <- c(vg1, vg2, vgi, ve)
    
    toc()
    # To calculate log likelihood, MM4LMM use gradient descent, meanwhile Eagle use grid.   
    if (!is.null(res$NullModel$`LogLik (ML)`)) {
      loglik <- res$NullModel$`LogLik (ML)`   
    } else {
      loglik <- res$NullModel$`LogLik (Reml)`
    }
    
    message(sprintf("log likelihood: %f, var G1: %f, var G2: %f, var vgi: %f, var E: %f", loglik, vg1, vg2, vgi, ve))
    
    #### #### #### ####    STEP 2 model evaluation   #### #### #### #### 
    # Degree of freedom of Eagle's extend BIC equals to 1
    bic <- -2 * loglik + (ncol(X)+1) * log(length(Pheno))
    ext_bic <- bic + 2 * gamma * lchoose(total_SNPs_num, length(selected_locus$order))
    
    message(sprintf("BIC: %f, extend BIC: %f", bic, ext_bic))
    
    bic_history <- c(bic_history, bic)
    extBIC_history <- c(extBIC_history, ext_bic)
    vg_history$G1 <- c(vg_history$G1, vg1)
    vg_history$G2 <- c(vg_history$G1, vg2)
    vg_history$IA <- c(vg_history$IA, vgi)
    vg_history$Error <- c(vg_history$Error, ve)
    loglik_history <- c(loglik_history, loglik)

    #### #### #### ####    STEP 3 model selection   #### #### #### ####  
    tic()
    Sigma_gamma <- diag(ve, nrow = nrow(G1$K_)) + vg1 * G1$K_ + vg2 * G2$K_ + vgi * IA$K_
    Sigma_gamma_1 <- chol2inv(cholesky(Sigma_gamma, parallel = TRUE))
    XtS_1 <- Crossprod(X, Sigma_gamma_1)
    P_gamma <-  Sigma_gamma_1 - chol2inv(cholesky(Crossprod(X, t(XtS_1)), parallel = TRUE)) %>% Crossprod(., XtS_1) %>% Crossprod(XtS_1, .)
    toc()
    
    break;
    
    scores <- .find.putative.qtl(G1, G2, IA, Y, P_gamma, Sigma_gamma)
    
    # if ( G1_score$score > G2_score$score) {
    #   loci_genome <- 1
    #   selected_locus$order <- c(selected_locus$order, 1)
    #   selected_locus$G1 <- c(selected_locus$G1, G1_score$loci_idx)
    #   selected_locus_names$G1 <- c(selected_locus_names$G1, G1_score$loci_name)
    #   loci_name <- G1_score$loci_name
    #   loci_idx  <- G1_score$loci_idx
    #   message(sprintf("[%s] new selected loci: %s, index: %d", genome_names[1], G1_score$loci_name, G1_score$loci_idx))
    # } else {
    #   loci_genome <- 2
    #   selected_locus$order <- c(selected_locus$order, 2)
    #   selected_locus$G2 <- c(selected_locus$G2, G2_score$loci_idx)
    #   selected_locus_names$G2 <- c(selected_locus_names$G2, G2_score$loci_name)
    #   loci_name <- G2_score$loci_name
    #   loci_idx  <- G2_score$loci_idx
    #   message(sprintf("[%s] new selected loci: %s, index: %d", genome_names[2], G2_score$loci_name, G2_score$loci_idx))
    # }
    
    
  }
}, warning = function(warn) {
  print(paste("EMG WARNING MESSAGE: ", warn))
}, error = function(err) {
  print(paste("EMG ERROR MESSAGE: ", err))
}, finally = function(f) {
  selected_locus$extBIC <- extBIC_history
  selected_locus$loglik <- loglik_history
})

selected_locus$extBIC <- extBIC_history
selected_locus$loglik <- loglik_history

```

