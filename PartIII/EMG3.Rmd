---
title: "Verify the socres of the interactions"
output: html_notebook
---

```{r}
require('MM4LMM')
require('tictoc')
require("sommer")
require("nnet")
require("parallel")
require("Rfast")
require("dplyr")
```

```{r}
# AMTOMM
PWD <- getwd()

Pheno <- read.csv(paste0(PWD, "/AMTOMM_DS/phenotype.txt"), header = FALSE, sep = " ")
names(Pheno) <- c("hostID", "pathogenID", "intercept", "X1", "X2")

Hosts <- t(read.csv(paste0(PWD, "/AMTOMM_DS/sequence_host.txt"), header = FALSE, sep = " "))
rownames(Hosts) <- c("chrID", "snpID", paste0(rep("H", 50), 1:50))
colnames(Hosts) <- paste0(Hosts[1,], rep("-", ncol(Hosts)), Hosts[2,])

Pathogens <- t(read.csv(paste0(PWD, "/AMTOMM_DS/sequence_pathogen.txt"), header = FALSE, sep = " "))
rownames(Pathogens) <- c("chrID", "snpID", paste0(rep("P", 40), 1:40))
colnames(Pathogens) <- paste0(Pathogens[1,], rep("-", ncol(Pathogens)), Pathogens[2,])

H <- Hosts[3:52,] * 2 - 1
P <- Pathogens[3:42,] * 2 - 1
HP<- .tensor.product(H,P)

while (TRUE) {
  Hs <- lapply(1:20, function(x) sort(sample(1:50, 20)))
  Ps <- lapply(1:20, function(x) sort(sample(1:40, 20)))  
  if (length(unique(unlist(Hs))) == 50 && length(unique(unlist(Ps))) == 40) break 
}

Zh <- matrix(0, ncol = 50,   nrow = 400)
Zp <- matrix(0, ncol = 40,   nrow = 400)
Zi <- matrix(0, ncol = 2000, nrow = 400)

for (i in 1:400) {
  Zh[i,  unlist(Hs)[i]] <- 1
  Zp[i,  unlist(Ps)[i]] <- 1
  Zi[i, (unlist(Hs)[i] - 1) * 40 + unlist(Ps)[i]] <- 1
}

# verifiy Zi
Z <- .row.tensor.product(Zh, Zp)
unique(as.numeric(Z - Zi))

```

#### Simulation

```{r}
gamma <- 0

ah_ <-  0 # fixed
ap_ <-  0 # fixed 
ai_ <- 20 # fixed 

nqtl.h = 10 # fixed
nqtl.p = 10 # fixed
nqtl.i = 10 # fixed

Freq.h <- colMeans(H)
Freq.p <- colMeans(P)
Freq.i <- colMeans(HP)
    
Poly.size.h <- 0 # fixed
Poly.size.p <- 0 # fixed
Poly.size.i <- 0 # fixed

Poly.effet.h <- 0
Poly.effet.p <- 0
Poly.effet.i <- 0

PWD <- paste0(getwd(),"/Test_Result02/")
label <- "[nqtl.h=%d][nqtl.p=%d][nqtl.i=%d][ah_=%d][ap_=%d][ai_=%d][Poly.size.h=%d][Poly.size.p=%d][Poly.size.i=%d][Poly.effet.h=%.3f][Poly.effet.p=%.3f][Poly.effet.i=%.3f][gamma=%.2f][h=%.2f][b=%.2f][tn=%d]"

save.model <- function(nqtl.h, nqtl.p, nqtl.i, Sh, Sp, Si, ahS, apS, aiS, ah_s, ap_s, ai_s, E, fname) {
  saveRDS(object = list("nqtl.h" = nqtl.h, "nqtl.p" = nqtl.p, "nqtl.i" = nqtl.i, "Sh" = Sh, "Sp" = Sp, "Si" = Si, 
                        "ahS" = ahS, "apS" = apS, "aiS" = aiS, "ah_s" = ah_s, "ap_s" = ap_s, "ai_s" = ai_s, "E" = E), 
                        file = fname)
}

save.trait <- function(Y, fname) {
  write.table(list("Trait" = Y), file = fname, 
              row.names =  FALSE, sep = " ", quote = FALSE)
}

sl.label <- function(h, b, tn) {
  return(sprintf(label, nqtl.h, nqtl.p, nqtl.i, ah_, ap_, ai_, Poly.size.h, Poly.size.p, Poly.size.i, Poly.effet.h, Poly.effet.p, Poly.effet.i, gamma, h, b, tn))
}

model.fname <- function(h, b, tn) {
  return(paste0(PWD, "model_", sl.label(h,b,tn), ".rds"))
}

trait.fname <- function(h, b, tn) {
  return(paste0(PWD, "trait_", sl.label(h,b,tn), ".dat"))
}

sl <- function (h, b, tn) {
  
  if (file.exists(model.fname(h,b,tn))) {
    return(NULL)
  }
  
  while(TRUE) {
    
    Informative.h <- which(Freq.h > 10/nrow(H) & Freq.h < 1-10/nrow(H))
    Informative.p <- which(Freq.p > 10/nrow(P) & Freq.p < 1-10/nrow(P))
    Informative.i <- which(Freq.i > 10/nrow(HP) & Freq.p < 1-10/nrow(HP))
    
    Lh <- ncol(H)
    Lp <- ncol(P)
    
    # Case nqtl.i == nqtl.h == nqtl.p
    # the interactions are in pairs
    Sh <- sample(Informative.h, nqtl.h)
    Sp <- sample(Informative.p, nqtl.p)
    Si <- unlist(lapply(1:nqtl.i, function(i) {
      Sh[i] * Lp + Sp[i]
    }))
    
    # Shp<- lapply(Sh, function(h) {lapply(Sp) {h*Lp + p}}) 
    # Shp<- intersect(Informative.i, Shp)
    # Si <- sample(Informative.i, nqtl.i)
    
    Hs <- H[, Sh]
    Ps <- P[, Sp]
    Is <- HP[,Si]
    
    H_s <- H[, -Sh]
    P_s <- P[, -Sp]
    I_s <- HP[,-Si]
    
    ah_s <- rep(0,ncol(H_s))
    ap_s <- rep(0,ncol(P_s))
    ai_s <- rep(0,ncol(I_s))

    ah_s[sample(1:length(ah_s), Poly.size.h)] <- runif(min = -Poly.effet.h, max = Poly.effet.h, n = Poly.size.h)
    ap_s[sample(1:length(ap_s), Poly.size.p)] <- runif(min = -Poly.effet.p, max = Poly.effet.p, n = Poly.size.p)
    ai_s[sample(1:length(ai_s), Poly.size.i)] <- runif(min = -Poly.effet.i, max = Poly.effet.i, n = Poly.size.i)
    
    ahS <- seq(ah_,ah_+nqtl.h,l=nqtl.h)
    apS <- seq(ap_,ap_+nqtl.p,l=nqtl.p)
    aiS <- seq(ai_,ai_+nqtl.i,l=nqtl.i)
    
    Uh <- Hs %*% ahS + H_s %*% ah_s
    Up <- Ps %*% apS + P_s %*% ap_s
    Ui <- Is %*% aiS + I_s %*% ai_s
    
    Uh <- Zh %*% Uh + Zp %*% Up + Zi %*% Ui
    Ua <- Zh %*% Hs %*% ahS + Zp %*% Ps %*% apS + Zi %*% Is %*% aiS
    
    vg <- var(Uh)
    va <- var(Ua)
    
    a_ratio <- va/vg
    
    # if (a_ratio < (b+0.02) && a_ratio > (b-0.02) && !file.exists(model.fname(h,b,tn))) {
    if (a_ratio < (b+0.02) && a_ratio > (b-0.02)) {
      sigma_E <- as.numeric(sqrt(vg*(1-h)/h))
      E <- sigma_E * rnorm(length(Uh))
      Y <- Uh + E
      save.model(nqtl.h = nqtl.h, nqtl.p = nqtl.p, nqtl.i = nqtl.i, 
                 Sh = Sh, Sp = Sp, Si = Si, ahS = ahS, apS = apS, aiS = aiS, 
                 ah_s = ah_s, ap_s = ap_s, ai_s = ai_s, E = E, fname = model.fname(h,b,tn))
      
      save.trait(Y, fname = trait.fname(h,b,tn))
      
      return(a_ratio)
    }
  }
}
```

```{r}
sl(h = 0.9, b = 1, tn = 1)
```

```{r}
Pheno <- read.csv(trait.fname(h = 0.9, b = 1, tn = 1))[, 1]
Y <- as.numeric(Pheno)

Geno1 <- as.matrix(H) - 1
Geno2 <- as.matrix(P) - 1

Z1 <- Zh
Z2 <- Zp
Zi <- Zi

max_itr_num <- 10
genome_names <- c("Host", "Pathogen")
Method <- "ML"
```


```{r}

.col.tensor.product<- function(A,B) {
  # rule: nrow(A) == row(B)
  return(matrix(mapply(function(x, i) x * B[,i], A, col(A)), ncol = ncol(A)))
}

.row.tensor.product<- function(A,B) {
  return(t(.col.tensor.product(t(A), t(B))))
}

.tensor.product <- function(A,B) {
  # https://en.wikipedia.org/wiki/Tensor_product
  AoB <- A%o%B
  return(do.call(rbind, mclapply(1:nrow(A), function(i) do.call(cbind,  lapply(1:ncol(A), function(j) (AoB)[i,j,,])), 
                                 mc.cores = getOption("mc.cores", 48L))))
}

selected_locus <- list("locus" = list(), "names" = list())

X1 <- matrix(data = 1, nrow = length(Pheno), ncol = 1)
colnames(X1) <- c("intercept")

Init  <- NULL
total_SNPs_num <- ncol(Geno1) + ncol(Geno2)

bic_history <- c()
extBIC_history <- c() 
loglik <- 0
loglik_history <- c()
vg_history <- list("G1"=c(), "G2"=c(), "IA" = c(), "Error"=c())

loci_name <- NULL
loci_genome <- NULL # equal to 1 or 2

.build.G <- function(Geno, Gname, Z = NULL, SNPs_names = NULL) {
  
  G <- list("Geno" = Geno, "Z" = Z, "K" = NULL, "K_" = NULL, "MMt" = NULL, "ZMMtZt" = NULL,
          "ZM" = NULL, "selected_locus" = NULL, "selected_locus_names" = NULL, "name" = Gname, 
          "SNPs_names" = SNPs_names, "ncol" = ncol(Geno))

  if (is.null(Z)) G$Z <- diag(ncol = nrow(G$Geno))
  
  if (is.null(SNPs_names)) G$SNPs_names <- colnames(G$Geno)
  
  if (is.null(G$SNPs_names)) {
    G$SNPs_names <- paste0(rep("SNP-", 1:ncol(Geno)))
    colnames(G$Geno) <- G$SNPs_names
  }

  G$MMt <- Tcrossprod(Geno, Geno)
  G$ZM  <- mat.mult(G$Z, Geno)
  G$ZMMtZt <- mat.mult(G$Z, Tcrossprod(G$MMt,G$Z))
  G$K <- G$MMt/mean(diag(G$MMt))
  G$K_<- G$ZMMtZt/mean(diag(G$ZMMtZt))
  
  return(G)
}

.build.IA <- function(G1, G2, Zi = NULL) {

  IA <- list("Z" = Zi, "K" = NULL, "selected_locus" = list(), "name" = "Interaction")

  if(is.null(Zi)) {
    IA$Z <- .row.tensor.product(G1$Z, G2$Z)
  }
  
  IA$K <- .tensor.product(G1$K, G2$K)
  IA$K_<-  mat.mult(IA$Z, Tcrossprod(IA$K,IA$Z))
  
  return(IA)
}

.update.G <- function(G, loci) {
  if (loci <= 0) return(G)
  # loci <- Geno$G[which(!selected_locus %in% Geno$selected_locus)]
  MMt_ <- tcrossprod(G$G[, loci])
  G$MMt <- G$MMt - MMt_
  G$ZMMtZt  <- G$ZMMtZt - mat.mult(Geno$Z, Tcrossprod(MMt_,G$Z))
  G$K   <- G$MMt/mean(diag(G$MMt))
  # ZMMtZt = Z %*% K %*% t(Z)
  G$K_  <- G$ZMMtZt/mean(diag(G$MMt))
  G$selected_locus <- c(G$selected_locus, loci)
  return(G)
}

.update.IA <- function(IA, G1, G2, loci_ia) {
  IA$K <- .tensor.product(G1$K, G2$K)
  IA$K_<-  mat.mult(IA$Z, Tcrossprod(IA$K,IA$Z))
  IA$selected_locus[[length(IA$selected_locus)+1]] <- as.numeric(loci_ia)
  return(IA)
}

.build.X <- function(X1, G1, G2, IA) {
  ZG1 <- as.matrix(G1$ZM[,G1$selected_locus])
  ZG2 <- as.matrix(G2$ZM[,G2$selected_locus])
  ZGI <- Crossprod(IA$Z, .tensor.product(ZG1, ZG2))
  X   <- cbind(X1, ZG1, ZG2, ZGI)
  return(X)
}

.calc.snps.scores <- function(a_hat, diag_var_a_hat, L, snps_names, selected_locus, genome_name) {
  # calculate snps scores
  indx <- which(diag_var_a_hat != 0)
  tsq <- a_hat[indx]^2/diag_var_a_hat[indx]
  names(tsq) <- seq(1, length(a_hat))[indx]
  best_score <- max(tsq, na.rm = TRUE)
  indx <- which(tsq == best_score)

  # deal with the case of more than one snps reach the best score
  midpoint <- 1
  if (length(indx) > 2) midpoint <- trunc(length(indx)/2) + 1
  indx <- indx[midpoint]
  orig_indx <- seq(1, L)
  loci_idx <- orig_indx[as.numeric(names(tsq))[indx]]

  # snps name and global index
  if (!is.null(selected_locus)) {
    score_names <- snps_names[-selected_locus]
  } else {
    score_names <- snps_names
  }

  loci_name <- score_names[loci_idx]
  loci_idx <- which(snps_names==loci_name)

  return(list("loci_name" = loci_name, "loci_idx" = loci_idx, "score" = best_score, "tsq" = tsq))
}


.find.putative.qtl <- function(G1, G2, IA, Y, P_gamma, Sigma_gamma) {
  
  PgY <- crossprod(P_gamma, Y)
  PSP <- Tcrossprod(P_gamma, Sigma_gamma) %>% Tcrossprod(., P_gamma)
  
  #### G1
  tic("G1:")
  if(is.null(G1$selected_locus)) {
    M1_s <- G1$G
  } else {
    M1_s <- G1$G[, -G1$selected_locus]
  }
  
  a1 <- Crossprod(G1$Z,PgY) %>% Crossprod(M1_s, .)
  P1 <- Crossprod(G1$Z, PSP) %>%  mat.mult(.,G1$Z)
  diag_var_a1 <- rowSums(Crossprod(M1_s, P1) * t(M1_s))
  score1 <- .calc.snps.scores(a1, diag_var_a1, ncol(G1$G), G1$SNPs_names, G1$selected_locus, G1$name)
  toc()
  
  #### G2 
  tic("G2:")
  if(is.null(G2$selected_locus)) {
    M2_s <- G2$G
  } else {
    M2_s <- G2$G[, -G2$selected_locus]
  }
  
  a2 <- Crossprod(G2$Z,PgY) %>% Crossprod(M2_s, .)
  P2 <- Crossprod(G2$Z, PSP) %>% mat.mult(.,G2$Z)  
  diag_var_a2 <- rowSums(Crossprod(M2_s, P2) * t(M2_s))
  score2 <- .calc.snps.scores(a2, diag_var_a2, ncol(G2$G), G2$SNPs_names, G2$selected_locus, G2$name)
  toc()
  
  #### Gi
  # mclapply super slow 
  # 2000 snps by lapply: 365.56 sec elapsed
  
  tic("Gi [1]:")
  if (is.null(G1$selected_locus)) {
    ZM1 <- G1$ZM
  } else {
    ZM1 <- G1$ZM[, - G1$selected_locus]
  }

  if (is.null(G2$selected_locus)) {
    ZM2 <- G2$ZM
  } else {
    ZM2 <- G2$ZM[, - G2$selected_locus]
  }

  scores_ia1 <- lapply(c(1:ncol(ZM1)), function(i) {
    ZM1ixZM2 <- ZM1[,i] * ZM2
    ai <- Crossprod(ZM1ixZM2, PgY)
    diag_var_ai <- colSums(t(Crossprod(ZM1ixZM2,PSP))*ZM1ixZM2)
    scorei <- .calc.snps.scores(ai, diag_var_ai, G2$ncol, G2$SNPs_names, G2$selected_locus, IA$name)
    return(scorei)
  })
  toc()
  
  tic("Gi [2]:")
  Mi_s <- .tensor.product(M1_s, M2_s)
  ai <- Crossprod(IA$Z, PgY) %>% Crossprod(Mi_s, .)
  Pi <- Crossprod(IA$Z, PSP) %>% mat.mult(.,IA$Z)
  diag_var_ai <- rowSums(Crossprod(Mi_s, Pi) * t(Mi_s))
  scores_ia2 <- .calc.snps.scores(ai, diag_var_ai, G1$ncol * G2$ncol, 
                paste(rep(G1$SNPs_names, each = G2$ncol), rep(G2$SNPs_names, G1$ncol), sep = "-"), NULL, IA)

  toc()
  return(list("G1" = score1, "G2" = score2, "IA1" = scores_ia1, "IA2" = scores_ia2))
}

```


```{r}

# tryCatch({

  for (itr_num in 1:max_itr_num) {
    
    message(sprintf("\nIteration: %d", itr_num))
    
    #### #### #### ####    STEP 1 model building    #### #### #### ####
    if (length(selected_locus$locus) == 0) {
      G1 <- .build.G(Geno = Geno1, Z = Z1, Gname = genome_names[1])
      G2 <- .build.G(Geno = Geno2, Z = Z2, Gname = genome_names[2])
      IA <- .build.IA(G1 = G1, G2 = G2, Zi = Zi)
      X  <- X1
    } else {
      locus_ia <- as.numeric(selected_locus$locus[[itr_num-1]])
      G1 <- .update.G(G = G1, loci = locus_ia[1])
      G2 <- .update.G(G = G2, loci = locus_ia[2])
      IA <- .update.IA(IA, G1, G2, locus_ia)
      X  <- .build.X(X1 = X1, G1 = G1, G2 = G2, IA = IA)
    }
    
    tic()
    VL <- list(G1 = G1$K, G2 = G2$K, IA = IA$K, Error = diag(1,length(Y)))
    ZL <- list(G1 = G1$Z, G2 = G2$Z, IA = IA$Z, Error = diag(1,length(Y)))
    
    if (!is.null(genome_names)) {
      names(VL) <- c(genome_names, "Interaction", "Error")
      names(ZL) <- c(genome_names, "Interaction", "Error")
    }
    
    if (is.null(Init)) {
      Init <- rep(var(Pheno)/4,4)
    }

    res <- MMEst(Y = Pheno, Cofactor = X, Method = Method,
                 VarList = VL, ZList = ZL, Init = Init,
                 MaxIter = 400, CritLogLik = 0.0001)

    # Note: vg, ve, loglik are very slightly different from Eagle's
    vg1 <- res$NullModel$Sigma2[genome_names[1]]
    vg2 <- res$NullModel$Sigma2[genome_names[2]]
    vgi <- res$NullModel$Sigma2["Interaction"]
    ve <- res$NullModel$Sigma2["Error"]
    
    Init <- c(vg1, vg2, vgi, ve)
    
    toc()
    # To calculate log likelihood, MM4LMM use gradient descent, meanwhile Eagle use grid.   
    if (!is.null(res$NullModel$`LogLik (ML)`)) {
      loglik <- res$NullModel$`LogLik (ML)`   
    } else {
      loglik <- res$NullModel$`LogLik (Reml)`
    }
    
    message(sprintf("log likelihood: %f, var G1: %f, var G2: %f, var vgi: %f, var E: %f", loglik, vg1, vg2, vgi, ve))
    
    #### #### #### ####    STEP 2 model evaluation   #### #### #### #### 
    # Degree of freedom of Eagle's extend BIC equals to 1
    bic <- -2 * loglik + (ncol(X)+1) * log(length(Pheno))
    ext_bic <- bic + 2 * gamma * lchoose(total_SNPs_num, length(selected_locus$order))
    
    message(sprintf("BIC: %f, extend BIC: %f", bic, ext_bic))
    
    bic_history <- c(bic_history, bic)
    extBIC_history <- c(extBIC_history, ext_bic)
    vg_history$G1 <- c(vg_history$G1, vg1)
    vg_history$G2 <- c(vg_history$G1, vg2)
    vg_history$IA <- c(vg_history$IA, vgi)
    vg_history$Error <- c(vg_history$Error, ve)
    loglik_history <- c(loglik_history, loglik)

    #### #### #### ####    STEP 3 model selection   #### #### #### ####  
    tic()
    Sigma_gamma <- diag(ve, nrow = nrow(G1$K_)) + vg1 * G1$K_ + vg2 * G2$K_ + vgi * IA$K_
    Sigma_gamma_1 <- chol2inv(cholesky(Sigma_gamma, parallel = TRUE))
    XtS_1 <- Crossprod(X, Sigma_gamma_1)
    P_gamma <-  Sigma_gamma_1 - chol2inv(cholesky(Crossprod(X, t(XtS_1)), parallel = TRUE)) %>% Crossprod(., XtS_1) %>% Crossprod(XtS_1, .)
    toc()
    
    scores <- .find.putative.qtl(G1, G2, IA, Y, P_gamma, Sigma_gamma)

    
    ia_scores_df <- as.data.frame(do.call(rbind, scores$IA1))
    ia_best_score <- as.numeric(ia_scores_df$score[which.max(ia_scores_df$score)])
    
    if ( scores$G1$score > scores$G2$score && scores$G1$score > ia_best_score) {
      selected_locus$locus[[itr_num]] <- c(scores$G1$loci_idx, 0)
      selected_locus$names[[itr_num]] <- c(scores$G1$loci_name,"")
      message(sprintf("[%s] new selected loci: %s, index: %d", genome_names[1], scores$G1$loci_name, scores$G1$loci_idx))
    } else if ( scores$G2$score > scores$G1$score && scores$G2$score > ia_best_score ) {
      selected_locus$locus[[itr_num]] <- c(0, scores$G2$loci_idx)
      selected_locus$names[[itr_num]] <- c("",scores$G2$loci_name)
      message(sprintf("[%s] new selected loci: %s, index: %d", genome_names[2], scores$G2$loci_name, scores$G2$loci_idx))
    } else {
      G1_best_idx <- which.max(ia_scores_df$score)
      G2_best_idx <- as.numeric(ia_scores_df$loci_idx[G1_best_idx])
      selected_locus$locus[[itr_num]] <- c(G1_best_idx, G2_best_idx)
      selected_locus$names[[itr_num]] <- c(G1$SNPs_names[G1_best_idx], G2$SNPs_names[G2_best_idx])
      message(sprintf("new interaction locus: %s and %s, index: %d and %d", 
                      G1$SNPs_names[G1_best_idx], G2$SNPs_names[G2_best_idx], G1_best_idx, G2_best_idx))
    }
    
    break
  }

# }, warning = function(warn) {
#   print(paste("EMG WARNING MESSAGE: ", warn))
# }, error = function(err) {
#   print(paste("EMG ERROR MESSAGE: ", err))
# }, finally = function(f) {
#   selected_locus$extBIC <- extBIC_history
#   selected_locus$loglik <- loglik_history
# })

selected_locus$extBIC <- extBIC_history
selected_locus$loglik <- loglik_history

```

#### QQ plot: interaction scores calculation, x is for simplified, y is for original

```{r}
plot(x= ia1_tsq[1:10000], y = scores$IA2$tsq[1:10000])

```

